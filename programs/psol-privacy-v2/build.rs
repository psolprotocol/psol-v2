use std::env;
use std::fs;
use std::path::PathBuf;

use ark_bn254::Fr;
use ark_ff::PrimeField;

// Build-time generator for Poseidon parameters.
//
// Why this exists:
// - `light-poseidon` provides circom-compatible BN254 Poseidon parameters,
//   but it is not suitable to link into a Solana BPF program (std + heap-heavy).
// - We use it ONLY at build-time to materialize constants into a generated Rust file.
// - The on-chain code consumes the generated constants with stack-only hashing logic.
fn main() {
    // Re-run if this build script changes.
    println!("cargo:rerun-if-changed=build.rs");
    // Silence `unexpected_cfgs` warnings for Solana programs on newer Rust toolchains.
    // The Solana ecosystem uses `#[cfg(target_os = "solana")]` to identify on-chain builds.
    println!("cargo:rustc-check-cfg=cfg(target_os, values(\"solana\"))");

    let out_dir = PathBuf::from(env::var("OUT_DIR").expect("OUT_DIR must be set"));
    let out_path = out_dir.join("poseidon_bn254_circom_params.rs");

    let t3 = generate_for_width(3);
    let t5 = generate_for_width(5);

    let rendered = format!(
        "\
// AUTO-GENERATED by build.rs. DO NOT EDIT.
// Source of truth: `light-poseidon` v0.4.0 parameters::bn254_x5::get_poseidon_parameters
//
// NOTE: We store field elements as raw BigInteger256 limbs ([u64; 4]) in little-endian limb order,
// matching arkworks BigInteger256 representation.
//
// Width 3 == Poseidon(2 inputs) (domain_tag + 2 inputs)
// Width 5 == Poseidon(4 inputs) (domain_tag + 4 inputs)

pub const POSEIDON_BN254_X5_ALPHA: u64 = 5;

pub const POSEIDON_BN254_T3_FULL_ROUNDS: usize = {t3_full};
pub const POSEIDON_BN254_T3_PARTIAL_ROUNDS: usize = {t3_partial};
pub const POSEIDON_BN254_T3_WIDTH: usize = 3;
pub const POSEIDON_BN254_T3_ARK: [[u64; 4]; {t3_ark_len}] = {t3_ark};
pub const POSEIDON_BN254_T3_MDS: [[[u64; 4]; 3]; 3] = {t3_mds};

pub const POSEIDON_BN254_T5_FULL_ROUNDS: usize = {t5_full};
pub const POSEIDON_BN254_T5_PARTIAL_ROUNDS: usize = {t5_partial};
pub const POSEIDON_BN254_T5_WIDTH: usize = 5;
pub const POSEIDON_BN254_T5_ARK: [[u64; 4]; {t5_ark_len}] = {t5_ark};
pub const POSEIDON_BN254_T5_MDS: [[[u64; 4]; 5]; 5] = {t5_mds};
",
        t3_full = t3.full_rounds,
        t3_partial = t3.partial_rounds,
        t3_ark_len = t3.ark.len(),
        t3_ark = t3.ark_rendered,
        t3_mds = t3.mds_rendered,
        t5_full = t5.full_rounds,
        t5_partial = t5.partial_rounds,
        t5_ark_len = t5.ark.len(),
        t5_ark = t5.ark_rendered,
        t5_mds = t5.mds_rendered,
    );

    fs::write(&out_path, rendered).expect("write generated poseidon params");
}

struct Generated {
    full_rounds: usize,
    partial_rounds: usize,
    ark: Vec<[u64; 4]>,
    ark_rendered: String,
    mds_rendered: String,
}

fn generate_for_width(width: u8) -> Generated {
    let params = light_poseidon::parameters::bn254_x5::get_poseidon_parameters::<Fr>(width)
        .unwrap_or_else(|e| panic!("failed to get Poseidon parameters for t={width}: {e:?}"));

    assert_eq!(
        params.width as u8, width,
        "light-poseidon returned mismatched width"
    );
    assert_eq!(params.alpha, 5, "unexpected Poseidon alpha");

    // Round constants: flatten and store as limbs.
    let ark_limbs: Vec<[u64; 4]> = params
        .ark
        .iter()
        .map(|f| f.into_bigint().0)
        .collect();

    // MDS: store as limbs.
    let mut mds_limbs: Vec<Vec<[u64; 4]>> = Vec::with_capacity(params.mds.len());
    for row in params.mds.iter() {
        let mut out_row: Vec<[u64; 4]> = Vec::with_capacity(row.len());
        for f in row.iter() {
            out_row.push(f.into_bigint().0);
        }
        mds_limbs.push(out_row);
    }

    let ark_rendered = render_2d_u64_4(&ark_limbs);
    let mds_rendered = render_mds(&mds_limbs);

    Generated {
        full_rounds: params.full_rounds,
        partial_rounds: params.partial_rounds,
        ark: ark_limbs,
        ark_rendered,
        mds_rendered,
    }
}

fn render_2d_u64_4(values: &[[u64; 4]]) -> String {
    let mut s = String::from("[\n");
    for v in values {
        s.push_str("    [");
        s.push_str(&format!("{}, {}, {}, {}", v[0], v[1], v[2], v[3]));
        s.push_str("],\n");
    }
    s.push_str("]\n");
    s
}

fn render_mds(values: &[Vec<[u64; 4]>]) -> String {
    let mut s = String::from("[\n");
    for row in values {
        s.push_str("    [\n");
        for v in row {
            s.push_str("        [");
            s.push_str(&format!("{}, {}, {}, {}", v[0], v[1], v[2], v[3]));
            s.push_str("],\n");
        }
        s.push_str("    ],\n");
    }
    s.push_str("]\n");
    s
}

