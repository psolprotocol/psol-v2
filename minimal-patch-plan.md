# Minimal Patch Plan (Revised)

This plan corrects the previously identified issues, ensuring that fixes target the appropriate components.

## Issue #1: Inconsistent `asset_id` Derivation (SDK Fix)

*   **File to change:** `sdk/src/crypto/keccak.ts`
*   **Function to change:** `deriveAssetId`
*   **Rationale:** The SDK's implementation is incorrect. It must match the on-chain program's domain-separated and field-element-safe derivation.
*   **Change:**

```typescript
// file: sdk/src/crypto/keccak.ts

import { keccak_256 } from '@noble/hashes/sha3';
import { PublicKey } from '@solana/web3.js';

// ... (keep existing keccak256 functions)

/**
 * Derive asset ID from mint address to match on-chain program.
 *
 * The on-chain program uses `asset_id = 0x00 || Keccak256("psol:asset_id:v1" || mint)[0..31]`
 * to ensure the result is a valid field element. This function replicates that logic.
 *
 * @param mint - Token mint public key
 * @returns Asset ID as 32-byte Uint8Array
 */
export function deriveAssetId(mint: PublicKey): Uint8Array {
  const hashInput = Buffer.concat([
    Buffer.from("psol:asset_id:v1"),
    mint.toBuffer(),
  ]);
  const digest = keccak_256(hashInput);

  // Prepend a zero byte to ensure the 256-bit value is less than the ~254-bit field modulus.
  const out = new Uint8Array(32);
  out.set(digest.slice(0, 31), 1); // out[0] is 0, copy digest into out[1..32]
  return out;
}
```

## Issue #2: Inconsistent Public Key Encoding (On-Chain Fix)

*   **File to change:** `programs/psol-privacy-v2/src/crypto/encoding.rs`
*   **Function to change:** `pubkey_to_be32` (and add dependencies)
*   **Rationale:** The on-chain program is at fault. It fails to reduce the 256-bit public key to a valid ~254-bit field element. The SDK/relayer's use of a modulo is correct and must be replicated on-chain for proofs to verify.
*   **Changes:**

1.  **Add `num-bigint` and `num-traits` to `Cargo.toml`:**
    ```toml
    # In programs/psol-privacy-v2/Cargo.toml
    [dependencies]
    # ... other dependencies
    num-bigint = "0.4"
    num-traits = "0.2"
    ```

2.  **Update the `pubkey_to_be32` function:**
    ```rust
    // In programs/psol-privacy-v2/src/crypto/encoding.rs

    use anchor_lang::prelude::*;
    use num_bigint::{BigUint, ToBigUint};
    use num_traits::Num;

    // ... (keep BN254_FR_MODULUS constant)

    /// Convert Pubkey to 32-byte scalar, ensuring it's a valid field element.
    ///
    /// A raw pubkey is a 256-bit value, which can be larger than the ~254-bit
    /// scalar field modulus. This function performs a modulo operation to map
    /// the pubkey into the field, matching the client-side logic.
    ///
    /// ⚠️ CRITICAL: This is required for proof verification to succeed.
    pub fn pubkey_to_be32(pubkey: &Pubkey) -> [u8; 32] {
        // Convert the modulus and pubkey bytes to BigUints
        let modulus = BigUint::from_bytes_be(&BN254_FR_MODULUS);
        let pubkey_as_uint = BigUint::from_bytes_be(&pubkey.to_bytes());

        // Perform the modulo operation
        let result_uint = pubkey_as_uint % modulus;

        // Convert the result back to a 32-byte big-endian array
        let mut result_bytes = result_uint.to_bytes_be();
        let mut out = [0u8; 32];
        let pad_len = 32_usize.saturating_sub(result_bytes.len());
        out[pad_len..].copy_from_slice(&result_bytes);
        out
    }
    ```

# Local Integration Test Plan

1.  **Update Dependencies:** Run `cargo update` in the `programs/psol-privacy-v2` directory to fetch the new `num-bigint` dependency.
2.  **Run Existing Tests:**
    *   `cargo test -p psol-privacy-v2`
    *   `cd circuits && npm test`
3.  **Create an Integration Test (`tests/integration.test.ts`):**
    *   **Test `asset_id` Derivation:**
        *   Generate a new mint `PublicKey`.
        *   Call the patched SDK `deriveAssetId` function.
        *   Create a test-only instruction in the Anchor program that calls `compute_asset_id` and returns the result.
        *   Call this on-chain instruction and assert that its return value equals the value generated by the SDK.
    *   **Test `pubkey` to Field Element Encoding:**
        *   Generate a new `PublicKey`.
        *   Call the `pubkeyToScalar` function in the SDK/relayer.
        *   Create a test-only instruction that calls the patched on-chain `pubkey_to_be32` function and returns the result.
        *   Call this on-chain instruction and assert that its return value, when converted to a BigInt, equals the value from the SDK.
    *   **Write an End-to-End Test:**
        *   Initialize a new pool locally.
        *   Set the verification keys from the build artifacts.
        *   Register a new asset.
        *   Perform a shielded deposit.
        *   Perform a shielded withdrawal to a new recipient public key.
        *   Assert that all transaction signatures are confirmed without errors.

## Issue #3: Merkle Tree Depth Mismatch (Script Fix)

*   **File to change:** `scripts/ts/init-pool.ts`
*   **Variable to change:** `treeDepth`
*   **Rationale:** The on-chain tree depth must match the circuit's hardcoded depth for proofs to be valid. The circuit expects a depth of 20.
*   **Change:**
    ```typescript
    // in scripts/ts/init-pool.ts
    const treeDepth = 20;
    ```
