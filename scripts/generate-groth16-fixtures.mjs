#!/usr/bin/env node
/**
 * Generate Groth16 proof fixtures for Rust tests
 *
 * Reads the deposit circuit's VK and proof, converts to Solana byte encoding,
 * and outputs Rust code that can be copy-pasted into groth16.rs tests.
 *
 * Usage: node scripts/generate-groth16-fixtures.mjs
 */

import { readFileSync } from 'fs';

// Convert bigint to 32-byte big-endian hex array for Rust
function toRustBytes(value) {
  const hex = BigInt(value).toString(16).padStart(64, '0');
  const bytes = [];
  for (let i = 0; i < 64; i += 2) {
    bytes.push('0x' + hex.slice(i, i + 2));
  }
  return bytes;
}

// Convert G1 point [x, y, "1"] to 64 Rust bytes
function g1ToRust(point) {
  const xBytes = toRustBytes(point[0]);
  const yBytes = toRustBytes(point[1]);
  return [...xBytes, ...yBytes];
}

// Convert G2 point [[x0,x1], [y0,y1], ["1","0"]] to 128 Rust bytes
// NOTE: Solana wants c1 BEFORE c0 (imaginary before real)
function g2ToRust(point) {
  const x0Bytes = toRustBytes(point[0][0]);
  const x1Bytes = toRustBytes(point[0][1]);
  const y0Bytes = toRustBytes(point[1][0]);
  const y1Bytes = toRustBytes(point[1][1]);
  // SWAP: c1 || c0 for each coordinate (Solana G2 encoding)
  return [...x1Bytes, ...x0Bytes, ...y1Bytes, ...y0Bytes];
}

// Format bytes array as Rust code
function formatRustArray(bytes, indent = 8) {
  const lines = [];
  const prefix = ' '.repeat(indent);
  for (let i = 0; i < bytes.length; i += 8) {
    const chunk = bytes.slice(i, i + 8);
    lines.push(prefix + chunk.join(', ') + ',');
  }
  return lines.join('\n');
}

function main() {
  // Read circuit artifacts
  const vk = JSON.parse(readFileSync('circuits/build/deposit_vk.json', 'utf8'));
  const proof = JSON.parse(readFileSync('circuits/build/deposit_proof.json', 'utf8'));
  const publicSignals = JSON.parse(readFileSync('circuits/build/deposit_public.json', 'utf8'));

  console.log('// ==========================================================================');
  console.log('// REAL GROTH16 DEPOSIT PROOF FIXTURE');
  console.log('// Generated by: node scripts/generate-groth16-fixtures.mjs');
  console.log('// ');
  console.log('// Public inputs: [commitment, amount, asset_id]');
  console.log('// ==========================================================================\n');

  // Verification Key
  console.log('let vk = VerificationKey {');
  console.log('    alpha_g1: [');
  console.log(formatRustArray(g1ToRust(vk.vk_alpha_1)));
  console.log('    ],');
  console.log('    beta_g2: [');
  console.log(formatRustArray(g2ToRust(vk.vk_beta_2)));
  console.log('    ],');
  console.log('    gamma_g2: [');
  console.log(formatRustArray(g2ToRust(vk.vk_gamma_2)));
  console.log('    ],');
  console.log('    delta_g2: [');
  console.log(formatRustArray(g2ToRust(vk.vk_delta_2)));
  console.log('    ],');
  console.log('    ic: vec![');
  for (const ic of vk.IC) {
    console.log('        [');
    console.log(formatRustArray(g1ToRust(ic), 12));
    console.log('        ],');
  }
  console.log('    ],');
  console.log('};\n');

  // Proof
  console.log('let proof = Proof {');
  console.log('    a: [');
  console.log(formatRustArray(g1ToRust(proof.pi_a)));
  console.log('    ],');
  console.log('    b: [');
  console.log(formatRustArray(g2ToRust(proof.pi_b)));
  console.log('    ],');
  console.log('    c: [');
  console.log(formatRustArray(g1ToRust(proof.pi_c)));
  console.log('    ],');
  console.log('};\n');

  // Public inputs
  console.log('// Public inputs: commitment, amount, asset_id');
  console.log(`// commitment = ${publicSignals[0]}`);
  console.log(`// amount = ${publicSignals[1]}`);
  console.log(`// asset_id = ${publicSignals[2]}`);
  console.log('let inputs: [Scalar; 3] = [');
  for (let i = 0; i < publicSignals.length; i++) {
    const label = ['commitment', 'amount', 'asset_id'][i];
    console.log(`    // ${label} = ${publicSignals[i]}`);
    console.log('    [');
    console.log(formatRustArray(toRustBytes(publicSignals[i]), 8));
    console.log('    ],');
  }
  console.log('];');
}

main();
